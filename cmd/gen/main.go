package main

import (
	"fmt"
	"go/types"
	"golang.org/x/tools/go/packages"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	. "github.com/dave/jennifer/jen"
)

func main() {
	if len(os.Args) < 2 {
		panic(fmt.Errorf("not enough arguments"))
	}

	sourceType := os.Args[1]
	sourceTypePkg, sourceTypeName := splitSourceType(sourceType)

	pkg := loadPkg(sourceTypePkg)

	obj := pkg.Types.Scope().Lookup(sourceTypeName)
	if obj == nil {
		panic(fmt.Errorf("type name not found"))
	}

	if _, ok := obj.(*types.TypeName); !ok {
		panic(fmt.Errorf("%v is not a named type", obj))
	}

	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		panic(fmt.Errorf("type %v is not a struct", obj))
	}

	err := generate(sourceTypeName, structType, pkg.String())
	if err != nil {
		panic(err)
	}

}

var structColPattern = regexp.MustCompile(`col:"([^"]+)"`)
var tableNamePattern = regexp.MustCompile(`table_name:"([^"]+)"`)

var (
	fields 		[]string
	fieldCols 	[]string
	cols 		[]string
	tableName 	string
)

func generate(sourceTypeName string, structType *types.Struct, pkgName string) error {

	// 1. Get the package of the file with go:generate comment
	goPackage := os.Getenv("GOPACKAGE")

	// 2. Start a new file in this package
	f := NewFile(goPackage)

	c := Qual(pkgName, "User")

	// 3. Add a package comment, so IDEs detect files as generated
	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	var toMapBlock []Code

	// 4. Iterate over struct fieldCols
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		tagValue := structType.Tag(i)
		match := structColPattern.FindStringSubmatch(tagValue)
		if s := tableNamePattern.FindStringSubmatch(tagValue); s != nil {
			tableName = s[1]
			continue
		}
		if match == nil {
			continue
		}
		col := match[1]
		fields = append(fields, fmt.Sprintf("d.%s",field.Name()))
		fieldCols = append(fieldCols, col)
		cols = append(cols, fmt.Sprintf("$%d", len(fields)))
	}


	CreateType(f, toMapBlock, c, sourceTypeName, fieldCols, cols, fields)

	// 6. Build the target file name
	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_" + strings.ToLower(sourceTypeName) + "_gen.go"

	// 7. Write generated file
	return f.Save(targetFilename)
}

func CreateType(f *File, toMapBlock []Code, c *Statement, sourceTypeName string, fieldCols, cols, fields []string) {
	code1 := If(Id("_, err")).
		Op(":=").
		Id(fmt.Sprintf("c.db.Exec(\"INSERT INTO %s (%s) VALUES (%s)\", %s)", tableName,
			strings.Join(fieldCols, ","), strings.Join(cols, ","), strings.Join(fields, ","))).
		Id("; err").Op("==").Id(" nil {").
		Return(Id("nil, err").
			Id("}"))

	toMapBlock = append(toMapBlock, code1)
	toMapBlock = append(toMapBlock, Return(Id("&d, nil")))


	// create func
	receiverT := "store"
	f.Func().Params(
		Id("c").Id(receiverT),
	).Id(fmt.Sprintf("Create%s", sourceTypeName)).Params(Id(fmt.Sprintf("d domain.%s", sourceTypeName))).
		Id("(*").List(c, Error()).Id(")").Block(
		toMapBlock...,
	)
}

func loadPkg(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		panic(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func splitSourceType(sourceType string) (string, string) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		panic(fmt.Errorf(`expected qualified type as "pkg/path.MyType"`))
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName
}